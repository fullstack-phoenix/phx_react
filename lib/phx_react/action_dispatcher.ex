defmodule PhxReact.ActionDispatcher do
  @moduledoc """
  Dispatches HTTP actions for registered PhxReact pages.
  """

  alias PhxReact.PageRegistry

  # PageRegistry is provided by the host application (generated by mix phx_react.install)
  @compile {:no_warn_undefined, PhxReact.PageRegistry}

  require Logger

  @type envelope ::
          %{status: :ok, data: map()}
          | %{status: :error, error: map()}
          | %{status: :redirect, to: String.t()}

  @spec dispatch(String.t(), String.t(), map(), map()) :: envelope()
  def dispatch(page_key, action_name, params, context \\ %{}) do
    with {:ok, page} <- PageRegistry.fetch(page_key),
         :ok <- validate_action(action_name),
         {:ok, normalized_params} <- validate_params(params) do
      invoke(page.module, action_name, normalized_params, context)
    else
      {:error, :unknown_page} ->
        error("unknown_page", "Unknown page key")

      {:error, :invalid_action} ->
        error("invalid_action", "Action must be a non-empty string")

      {:error, :invalid_params} ->
        error("invalid_params", "Action params must be an object")
    end
  end

  @spec ok(map()) :: envelope()
  def ok(data \\ %{}) when is_map(data), do: %{status: :ok, data: data}

  @spec error(String.t(), String.t(), map()) :: envelope()
  def error(code, message, details \\ %{}) do
    %{status: :error, error: %{code: code, message: message, details: details}}
  end

  @spec redirect(String.t()) :: envelope()
  def redirect(to) when is_binary(to), do: %{status: :redirect, to: to}

  defp invoke(module, action_name, params, context) do
    cond do
      function_exported?(module, :handle_action, 3) ->
        module.handle_action(action_name, params, context)
        |> normalize_result(action_name)

      function_exported?(module, :handle_http_action, 3) ->
        module.handle_http_action(action_name, params, context)
        |> normalize_result(action_name)

      true ->
        ok(%{accepted: true, action: action_name})
    end
  rescue
    error ->
      Logger.error("""
      Action dispatch failed
      module=#{inspect(module)} action=#{inspect(action_name)} error=#{Exception.message(error)}
      """)

      error("action_failed", "Action dispatch failed")
  end

  defp normalize_result({:ok, data}, _action_name) when is_map(data), do: ok(data)

  defp normalize_result({:error, reason}, _action_name),
    do: error("action_error", error_message(reason))

  defp normalize_result({:redirect, to}, _action_name) when is_binary(to), do: redirect(to)

  defp normalize_result(%{status: status} = envelope, _action_name)
       when status in [:ok, :error, :redirect],
       do: envelope

  defp normalize_result(:ok, action_name), do: ok(%{accepted: true, action: action_name})
  defp normalize_result(other, _action_name), do: ok(%{result: other})

  defp validate_action(action_name) when is_binary(action_name) and byte_size(action_name) > 0,
    do: :ok

  defp validate_action(_action_name), do: {:error, :invalid_action}

  defp validate_params(params) when is_map(params), do: {:ok, params}
  defp validate_params(_params), do: {:error, :invalid_params}

  defp error_message(reason) when is_binary(reason), do: reason
  defp error_message(reason), do: inspect(reason)
end
