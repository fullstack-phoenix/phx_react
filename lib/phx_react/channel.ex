defmodule PhxReact.Channel do
  @moduledoc """
  Phoenix Channel for PhxReact communication.

  Handles WebSocket connections and bridges them with Page GenServer processes.

  Topic format: "phx_react:<page_key>:<session_id>"
  """

  use Phoenix.Channel

  alias PhxReact.PageRegistry

  # PageRegistry is provided by the host application (generated by mix phx_react.install)
  @compile {:no_warn_undefined, PhxReact.PageRegistry}

  require Logger

  @impl true
  def join("phx_react:" <> rest, %{"token" => token}, socket) do
    case parse_topic(rest) do
      {:ok, page_key, session_id} ->
        case verify_token(socket, token) do
          {:ok, payload} ->
            validate_topic(payload, page_key, session_id)
            |> case do
              :ok -> start_page_process(socket, page_key, session_id, payload)
              {:error, reason} -> {:error, %{reason: reason}}
            end

          {:error, reason} ->
            Logger.error("Token verification failed: #{inspect(reason)}")
            {:error, %{reason: "invalid_token"}}
        end

      {:error, reason} ->
        Logger.error("Invalid topic format: #{inspect(reason)}")
        {:error, %{reason: "invalid_topic"}}
    end
  end

  def join(_topic, _payload, _socket) do
    {:error, %{reason: "invalid_topic"}}
  end

  @impl true
  def handle_in("event", %{"name" => event_name, "params" => params}, socket) do
    page_pid = socket.assigns[:page_pid]

    cond do
      not is_binary(event_name) ->
        {:reply, {:error, %{reason: "invalid_event"}}, socket}

      not is_map(params) ->
        {:reply, {:error, %{reason: "invalid_event"}}, socket}

      not is_pid(page_pid) ->
        {:reply, {:error, %{reason: "no_page_process"}}, socket}

      true ->
        GenServer.cast(page_pid, {:event, event_name, params})
        {:noreply, socket}
    end
  end

  def handle_in("event", _payload, socket) do
    if socket.assigns[:page_pid] do
      {:reply, {:error, %{reason: "invalid_event"}}, socket}
    else
      {:reply, {:error, %{reason: "no_page_process"}}, socket}
    end
  end

  def handle_in("invalidate", params, socket) when is_map(params) do
    push(socket, "invalidate", %{reason: Map.get(params, "reason", "manual")})
    {:noreply, socket}
  end

  def handle_in(_event, _payload, socket) do
    {:noreply, socket}
  end

  @impl true
  def handle_info({:state, assigns}, socket) do
    previous_assigns = socket.assigns[:last_assigns] || %{}
    changed_keys = changed_keys(previous_assigns, assigns)

    push(socket, "state", %{assigns: assigns, changed_keys: changed_keys})
    {:noreply, assign(socket, :last_assigns, assigns)}
  end

  def handle_info({:reply, reply}, socket) do
    push(socket, "reply", reply)
    {:noreply, socket}
  end

  def handle_info({:invalidate, payload}, socket) when is_map(payload) do
    push(socket, "invalidate", payload)
    {:noreply, socket}
  end

  def handle_info({:DOWN, _ref, :process, page_pid, reason}, socket) do
    if socket.assigns[:page_pid] == page_pid do
      Logger.info("Page process #{inspect(page_pid)} terminated: #{inspect(reason)}")
      {:stop, :normal, socket}
    else
      {:noreply, socket}
    end
  end

  def handle_info(_msg, socket) do
    {:noreply, socket}
  end

  @impl true
  def terminate(_reason, socket) do
    if page_pid = socket.assigns[:page_pid] do
      # Stop the page process gracefully
      Process.exit(page_pid, :normal)
    end

    :ok
  end

  # Private functions

  defp parse_topic(rest) do
    case String.split(rest, ":", parts: 2) do
      [page_key, session_id] when byte_size(page_key) > 0 and byte_size(session_id) > 0 ->
        {:ok, page_key, session_id}

      _ ->
        {:error, :invalid_format}
    end
  end

  defp verify_token(socket, token) do
    # Token expires in 24 hours
    max_age = 24 * 60 * 60

    case Phoenix.Token.verify(socket, "phx_react_session", token, max_age: max_age) do
      {:ok, session} -> {:ok, session}
      {:error, reason} -> {:error, reason}
    end
  end

  defp validate_topic(payload, topic_page_key, topic_session_id) do
    token_page_key = Map.get(payload, "page_key")
    token_session_id = Map.get(payload, "session_id")

    cond do
      token_page_key != topic_page_key -> {:error, "token_topic_mismatch"}
      token_session_id != topic_session_id -> {:error, "token_topic_mismatch"}
      true -> :ok
    end
  end

  defp start_page_process(socket, page_key, session_id, payload) do
    with {:ok, page} <- PageRegistry.fetch(page_key),
         params <- Map.get(payload, "params", %{}),
         session <- Map.get(payload, "session", %{}),
         {:ok, page_pid} <-
           PhxReact.PageSupervisor.start_page(page.module, params, session, self()) do
      Process.monitor(page_pid)

      socket =
        socket
        |> assign(:page_pid, page_pid)
        |> assign(:page_key, page_key)
        |> assign(:session_id, session_id)
        |> assign(:last_assigns, %{})

      Logger.info("Started page process #{inspect(page.module)} with pid #{inspect(page_pid)}")
      {:ok, socket}
    else
      {:error, :unknown_page} ->
        {:error, %{reason: "unknown_page"}}

      {:error, reason} ->
        Logger.error("Failed to start page process: #{inspect(reason)}")
        {:error, %{reason: "failed_to_start_page"}}
    end
  end

  defp changed_keys(previous, current) do
    previous_keys = Map.keys(previous)
    current_keys = Map.keys(current)
    all_keys = MapSet.union(MapSet.new(previous_keys), MapSet.new(current_keys))

    all_keys
    |> Enum.reduce([], fn key, acc ->
      if Map.get(previous, key) == Map.get(current, key), do: acc, else: [key | acc]
    end)
    |> Enum.reverse()
  end
end
